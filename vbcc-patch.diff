diff -Nur vbcc/config/z vbcc-patched/config/z
--- vbcc/config/z	1969-12-31 16:00:00.000000000 -0800
+++ vbcc-patched/config/z	2012-06-05 11:17:56.000000000 -0700
@@ -0,0 +1,5 @@
+-cc=../bin/vbccz -quiet %s -o=%s %s -O=%ld
+-ccv=../bin/vbccz %s -o=%s %s -O=%ld
+-as=cp %s %s
+-ld=echo "Don't know how to link Z-machine code" 1>&2; exit 0
+-rm=rm %s
diff -Nur vbcc/datatypes/dtgen.c vbcc-patched/datatypes/dtgen.c
--- vbcc/datatypes/dtgen.c	2012-06-05 12:54:33.000000000 -0700
+++ vbcc-patched/datatypes/dtgen.c	2012-06-05 11:17:56.000000000 -0700
@@ -133,8 +133,8 @@
   do{
     printf("Type y or n [%s]: ",def);
     fflush(stdout);
-    fgets(in,sizeof(in),stdin);
-    if(*in=='\n') strcpy(in,def);
+    if (fgets(in,sizeof(in),stdin) == NULL || *in == '\n')
+      strcpy(in,def);
   }while(*in!='y'&&*in!='n');
   return *in=='y';
 }
diff -Nur vbcc/frontend/vc.c vbcc-patched/frontend/vc.c
--- vbcc/frontend/vc.c	2012-06-05 12:54:33.000000000 -0700
+++ vbcc-patched/frontend/vc.c	2012-06-05 11:17:56.000000000 -0700
@@ -2,6 +2,7 @@
 /*  (c) in 1995-2010 by Volker Barthelmann  */
 /*  #define AMIGA for Amiga-Version         */
 
+#include <assert.h>
 #include <stdlib.h>
 #include <string.h>
 #include <stdio.h>
@@ -204,41 +205,50 @@
     }
 }
 
+static char *derelativize(int from_cfg, char *old_path)
+{
+    if (from_cfg && !strncmp(old_path, "../", 3)) {
+        char *vbcc_dir = getenv("VBCC");
+        int vbcc_dir_len;
+        char *new_path;
+        assert(vbcc_dir != NULL);  /* or we'd already have bailed */
+        vbcc_dir_len = strlen(vbcc_dir);
+        new_path = malloc(vbcc_dir_len + 1 + strlen(old_path+3) + 1);
+        sprintf(new_path, "%s%s%s",
+                vbcc_dir,
+                vbcc_dir[vbcc_dir_len-1] == '/' ? "" : "/",
+                old_path+3);
+        return new_path;
+    }
+    return old_path;
+}
+
 static int read_config(const char *cfg_name)
 {
     int i,count; long size;
-    char *p,*name;
-    FILE *file=0;
-    for(i=0;i<sizeof(search_dirs)/sizeof(search_dirs[0]);i++){
-      name=malloc(strlen(search_dirs[i])+strlen(cfg_name)+1);
-      if(!name) {printf(nomem);raus(EXIT_FAILURE);}
-      strcpy(name,search_dirs[i]);
-      strcat(name,cfg_name);
-      file=fopen(name,"r");
-      free(name);
-      if(file) break;
-    }
-    if(!file){
-      p=getenv("VBCC");
-      if(p){
-        name=malloc(strlen(p)+strlen(cfg_name)+20);
-        if(!name){printf(nomem);raus(EXIT_FAILURE);}
-        strcpy(name,p);
-#if defined(_WIN32)||defined(MSDOS)||defined(ATARI)
-        strcat(name,"\\config\\");
-        strcat(name,cfg_name);
-#elif defined(AMIGA)
-        AddPart(name,"config",strlen(p)+strlen(cfg_name)+20);
-        AddPart(name,(STRPTR)cfg_name,strlen(p)+strlen(cfg_name)+20);
-#else
-        strcat(name,"/config/");
-        strcat(name,cfg_name);
-#endif
-        file=fopen(name,"r");
-        free(name);
-      }
+    char *p;
+    char *vbcc_dir = getenv("VBCC");
+    int vbcc_dir_len;
+    char *config_fullpath;
+    FILE *file;
+    if (vbcc_dir == NULL) {
+        puts("Environment variable VBCC must point to the vbcc install directory!");
+        raus(EXIT_FAILURE);
+    }
+    vbcc_dir_len = strlen(vbcc_dir);
+    config_fullpath = malloc(vbcc_dir_len + 1 + 7 + strlen(cfg_name) + 1);
+    sprintf(config_fullpath, "%s%s%s%s",
+            vbcc_dir,
+            vbcc_dir[vbcc_dir_len-1] == '/' ? "" : "/",
+            "config/",
+            cfg_name);
+    file = fopen(config_fullpath, "r");
+    if (file == NULL) {
+        printf("Config file %s not found!\n"
+               "Is environment variable VBCC set correctly?\n",
+               config_fullpath);
+        raus(EXIT_FAILURE);
     }
-    if(!file) {puts("No config file!");raus(EXIT_FAILURE);}
     if(fseek(file,0,SEEK_END)) return 0;
     size=ftell(file);
     if(fseek(file,0,SEEK_SET)) return 0;
@@ -333,25 +343,26 @@
         if(!strncmp(parm,"-ul=",4)){ul=parm+4;*parm=0;}
     }
     for(i=1;i<argc+count;i++){
-        if(i<argc) parm=argv[i]; else parm=confp[i-argc];
+        int from_cfg = (i >= argc);
+        parm = (from_cfg ? confp[i-argc] : argv[i]);
 /*        printf("Parameter %d=%s\n",i,parm);*/
         if(!strncmp(parm,"-ldnodb=",8)){nodb=parm+8;*parm=0;}
         if(!strncmp(parm,"-ldstatic=",10)){staticflag=parm+10;*parm=0;}
         if(!strcmp(parm,"-g")) db=1;
         if(!strcmp(parm,"-static")){staticmode=1;*parm=0;}
         if(!strncmp(parm,"-ml=",4)){MAXCLEN=atoi(parm+4);*parm=0;}
-        if(!strncmp(parm,"-pp=",4)){ppname=parm+4;*parm=0;}
-        if(!strncmp(parm,"-cc=",4)){ccname=parm+4;*parm=0;}
-        if(!strncmp(parm,"-as=",4)){asname=parm+4;*parm=0;}
-        if(!strncmp(parm,"-ld=",4)){ldname=parm+4;*parm=0;}
-        if(!strncmp(parm,"-l2=",4)){l2name=parm+4;*parm=0;}
-        if(!strncmp(parm,"-rm=",4)){rmname=parm+4;*parm=0;}
-        if(!strncmp(parm,"-ppv=",5)){ppv=parm+5;*parm=0;}
-        if(!strncmp(parm,"-ccv=",5)){ccv=parm+5;*parm=0;}
-        if(!strncmp(parm,"-asv=",5)){asv=parm+5;*parm=0;}
-        if(!strncmp(parm,"-ldv=",5)){ldv=parm+5;*parm=0;}
-        if(!strncmp(parm,"-l2v=",5)){l2v=parm+5;*parm=0;}
-        if(!strncmp(parm,"-rmv=",5)){rmv=parm+5;*parm=0;}
+        if(!strncmp(parm,"-pp=",4)){ppname=derelativize(from_cfg, parm+4);*parm=0;}
+        if(!strncmp(parm,"-cc=",4)){ccname=derelativize(from_cfg, parm+4);*parm=0;}
+        if(!strncmp(parm,"-as=",4)){asname=derelativize(from_cfg, parm+4);*parm=0;}
+        if(!strncmp(parm,"-ld=",4)){ldname=derelativize(from_cfg, parm+4);*parm=0;}
+        if(!strncmp(parm,"-l2=",4)){l2name=derelativize(from_cfg, parm+4);*parm=0;}
+        if(!strncmp(parm,"-rm=",4)){rmname=derelativize(from_cfg, parm+4);*parm=0;}
+        if(!strncmp(parm,"-ppv=",5)){ppv=derelativize(from_cfg, parm+5);*parm=0;}
+        if(!strncmp(parm,"-ccv=",5)){ccv=derelativize(from_cfg, parm+5);*parm=0;}
+        if(!strncmp(parm,"-asv=",5)){asv=derelativize(from_cfg, parm+5);*parm=0;}
+        if(!strncmp(parm,"-ldv=",5)){ldv=derelativize(from_cfg, parm+5);*parm=0;}
+        if(!strncmp(parm,"-l2v=",5)){l2v=derelativize(from_cfg, parm+5);*parm=0;}
+        if(!strncmp(parm,"-rmv=",5)){rmv=derelativize(from_cfg, parm+5);*parm=0;}
         if(!strncmp(parm,"-cf=",4)){cf=parm+4;*parm=0;}
         if(!strncmp(parm,"-isc=",5)){scname=parm+5;*parm=0;}
         if(!strncmp(parm,"-iscv=",6)){scv=parm+6;*parm=0;}
diff -Nur vbcc/ic.c vbcc-patched/ic.c
--- vbcc/ic.c	2012-06-05 12:54:33.000000000 -0700
+++ vbcc-patched/ic.c	2012-06-05 12:51:55.000000000 -0700
@@ -1,5 +1,6 @@
 /*  $VER: vbcc (ic.c) V0.8  */
 
+#include <assert.h>
 #include "vbc.h"
 #include "opt.h"
 
@@ -488,6 +489,139 @@
   return new;
 }
 
+/* This function serves a dual purpose: it turns the const_list into a nice
+ * C string, but it also checks to see if it's all printable ASCII, and if
+ * it's not, we simply return NULL. Our caller is responsible for doing the
+ * right thing in that case. */
+static char *const_list_to_string(struct const_list *cl)
+{
+    int len = 0;
+    for (struct const_list *cx = cl; cx != NULL; cx = cx->next, ++len) {
+	int ch = cx->other->val.vchar;
+	switch (ch) {
+	    case '\0': if (cx->next != NULL) return NULL; break;
+	    case '\t': case '\n': /* okay */ break;
+	    default:
+		if (ch < 32 || 126 < ch) return NULL;
+		if (cx->next == NULL) return NULL;  /* not null-terminated */
+		break;
+	}
+    }
+    /* Okay, the string is a valid, printable string. */
+    char *text = mymalloc(len);
+    int i = 0;
+    for (struct const_list *cx = cl; cx != NULL; cx = cx->next, ++i) {
+	text[i] = cx->other->val.vchar;
+    }
+    return text;
+}
+
+static struct const_list *string_to_const_list(const char *text)
+{
+    struct const_list *cl = NULL;
+    struct const_list **pp = &cl;
+    for (int i=0; /*true*/; ++i) {
+	*pp = mymalloc(CLS);
+	(*pp)->tree = NULL;
+	(*pp)->idx = i;
+	(*pp)->val.vmax = 0;
+	(*pp)->other = mymalloc(CLS);
+	(*pp)->other->next = (*pp)->other->other = NULL;
+	(*pp)->other->tree = NULL;
+	(*pp)->other->idx = 0;
+	(*pp)->other->val.vchar = text[i];
+	pp = &(*pp)->next;
+	*pp = NULL;
+	if (text[i] == '\0')
+	    break;
+    }
+    return cl;
+}
+
+/* Emit a call to printf() with the given arguments. We expect that parameter "p"
+ * will point to an existing printf call, so all we need to do is swap out the
+ * arguments. */
+static void emit_printf(np p, const char *fmt, struct argument_list *other_args)
+{
+    struct argument_list *al = p->alist;
+    assert(al->arg->flags == ADDRESSA);
+    assert(al->arg->left->flags == STRING);
+    struct const_list *saved_cl = al->arg->left->cl;
+    struct const_list *cl = string_to_const_list(fmt);
+    al->arg->left->cl = cl;
+    /* Shrink the declared size of the string literal's char-array type. */
+    int saved_size = al->arg->left->ntyp->size;
+    int length = 0;
+    for (struct const_list *sx = cl; sx; sx = sx->next)
+	++length;
+    assert(length >= 1);
+    al->arg->left->ntyp->size = length;
+    
+    struct argument_list *saved_alist = p->alist;
+    struct argument_list *new_alist = mymalloc(sizeof(struct argument_list));
+    new_alist->arg = al->arg;
+    new_alist->next = other_args;
+    p->alist = new_alist;
+
+    assert(strcmp(p->left->left->o.v->identifier, "printf") == 0);
+    gen_IC(p, /*ltrue=*/0, /*lfalse=*/0);
+
+    p->alist = saved_alist;
+    al->arg->left->cl = saved_cl;
+    al->arg->left->ntyp->size = saved_size;
+    free(new_alist);
+}
+
+static void emit_puts(np p, const char *text)
+{
+    int cap = strlen(text) + 16;
+    char *inline_asm = mymalloc(cap);
+    int len = 8;
+    strcpy(inline_asm, "\tprint \"");
+    for (int i=0; text[i] != '\0'; ++i) {
+	if (len+10 >= cap) {
+	    cap += 20;
+	    inline_asm = myrealloc(inline_asm, cap);
+	}
+	switch (text[i]) {
+	    case '\n': inline_asm[len++] = '^'; break;
+	    case '\t': strcpy(inline_asm+len, "@{9}"); len += 4; break;
+	    case '"': inline_asm[len++] = '~'; break;
+	    case '@': strcpy(inline_asm+len, "@{40}"); len += 5; break;
+	    case '\\': strcpy(inline_asm+len, "@{5c}"); len += 5; break;
+	    case '~': strcpy(inline_asm+len, "@{7e}"); len += 5; break;
+	    case '^': strcpy(inline_asm+len, "@@94\",\""); len += 7; break;
+	    default:
+		/* This should have been assured by const_list_to_string(). */
+		assert(32 <= text[i] && text[i] <= 126);
+		inline_asm[len++] = text[i];
+		break;
+	}
+    }
+    strcpy(inline_asm+len, "\";\n");
+
+    char pfname[50];
+    static int counter = 0;
+    struct Typ voidt = {VOID};
+    struct Typ *voidfunctyp = new_typ();
+    sprintf(pfname, "XXinternal_pf_%07x_puts", ++counter);
+    voidfunctyp->next = clone_typ(&voidt);  /* returning void */
+    voidfunctyp->exact = mymalloc(sizeof *voidfunctyp->exact);
+    voidfunctyp->exact->count = 0;  /* taking unspecified arguments */
+    voidfunctyp->flags = FUNKT;
+    struct Var *pseudofunc = add_var(pfname, voidfunctyp, EXTERN, NULL);
+    pseudofunc->fi = new_fi();
+    pseudofunc->fi->inline_asm = inline_asm;
+
+    struct Var *saved_v = p->left->left->o.v;
+    struct argument_list *saved_alist = p->alist;
+    p->left->left->o.v = pseudofunc;
+    p->alist = NULL;
+    gen_IC(p, /*ltrue=*/0, /*lfalse=*/0);
+    p->left->left->o.v = saved_v;
+    p->alist = saved_alist;
+}
+
 
 void gen_IC(np p,int ltrue,int lfalse)
 /*  Erzeugt eine IC-Liste aus einer expression      */
@@ -915,6 +1049,100 @@
         struct IC *merk_fp,*lp;
 	unsigned int merk_opushed=opushed;
 #endif
+	/* [ajo] The following code optimizes puts("hello") into a single
+	 * Z-machine opcode: print "hello". This cuts down a little bit on
+	 * code size, but greatly on static data size, because (as far as I
+	 * know) the Z-machine stores text strings differently from regular
+	 * static data. */
+        if (ltrue == 0 && lfalse == 0 &&
+	    p->left->flags==ADDRESS &&
+            p->left->left->flags==IDENTIFIER &&
+            p->left->left->o.v->storage_class==EXTERN &&
+            !strcmp(p->left->left->o.v->identifier, "puts")) {
+            /* Generating IC for puts() of something */
+            struct argument_list *al = p->alist;
+            if (al != NULL && al->arg != NULL && al->arg->flags == ADDRESSA &&
+                al->arg->left != NULL && al->arg->left->flags == STRING &&
+		al->next == NULL) {
+                /* Generating IC for puts() of a string literal */
+                char *text = const_list_to_string(al->arg->left->cl);
+		if (text != NULL) {
+		    text = myrealloc(text, strlen(text)+2);
+		    strcat(text, "\n");
+		    emit_puts(p, text);
+		    free(text);
+		    return;
+		}
+            }
+        }
+
+	/* [ajo] The following code optimizes printf("prefix%ssuffix\n", arg)
+	 * into printf("prefix%s", arg); puts("suffix");
+	 * Again, this is very useful on the Z-machine. */
+        if (ltrue == 0 && lfalse == 0 &&
+	    p->left->flags==ADDRESS &&
+            p->left->left->flags==IDENTIFIER &&
+            p->left->left->o.v->storage_class==EXTERN &&
+            !strcmp(p->left->left->o.v->identifier, "printf")) {
+            /* Generating IC for printf() of something */
+            struct argument_list *al = p->alist;
+            if (al != NULL && al->arg != NULL && al->arg->flags == ADDRESSA &&
+                al->arg->left != NULL && al->arg->left->flags == STRING) {
+                /* Generating IC for printf("literal", ...) */
+		char *fmt = const_list_to_string(al->arg->left->cl);
+		if (fmt != NULL) {
+		    int start = 0;
+		    int end;
+		    struct argument_list *current_argument = al->next;
+		    for (end = 0; fmt[end] != '\0'; ++end) {
+			if (fmt[end] != '%')
+			    continue;
+			/* We've hit a format specifier. */
+			if (start != end) {
+			    /* There's some plaintext to print before we
+			     * get to this format specifier. */
+			    fmt[end] = '\0';
+			    emit_puts(p, fmt+start);
+			    fmt[end] = '%';
+			    start = end;
+			}
+			if (fmt[end+1] == 's' || fmt[end+1] == 'd') {
+			    /* We can handle this. */
+			    char saved_ch = fmt[end+2];
+			    if (saved_ch == '\0') goto dont_optimize_printf;
+			    struct argument_list *saved_al = current_argument->next;
+			    fmt[end+2] = '\0';
+			    current_argument->next = NULL;
+			    emit_printf(p, fmt+end, current_argument);
+			    fmt[end+2] = saved_ch;
+			    current_argument->next = saved_al;
+			    /* Advance to the next unconsumed argument. */
+			    current_argument = current_argument->next;
+			    start = end = end+2;
+			} else {
+			    /* Unknown format specifier. Be conservative. */
+			    if (start != 0) {
+				/* Chop off the bit we've already printed. */
+				emit_printf(p, fmt+start, current_argument);
+				return;
+			    } else {
+				goto dont_optimize_printf;
+			    }
+			}
+		    }
+		    if (start != end) {
+			/* There's plaintext at the end of the format string. */
+			emit_puts(p, fmt+start);
+		    }
+		    /* If we've reached here, we're done emitting the
+		     * optimized code, and we can stop. */
+		    free(fmt);
+		    return;
+		}
+	    }
+        }
+    dont_optimize_printf:
+
         if(p->left->flags==ADDRESS&&p->left->left->flags==IDENTIFIER){
             struct Var *v;
             gen_IC(p->left,0,0); r=1;
diff -Nur vbcc/machines/z/machine.c vbcc-patched/machines/z/machine.c
--- vbcc/machines/z/machine.c	2012-06-05 12:54:33.000000000 -0700
+++ vbcc-patched/machines/z/machine.c	2012-06-05 11:17:56.000000000 -0700
@@ -60,6 +60,10 @@
 static char FILE_[]=__FILE__;
 char cg_copyright[]="vbcc code-generator for Z-machine V0.0a (c) in 2001 by David Given";
 
+extern char *strdup(const char *);
+
+#define NOT_ON_STACK 999999
+
 /* Command-line flags. */
 
 int g_flags[MAXGF] = {
@@ -68,6 +72,7 @@
 	0,
 	0,
 	0,
+	0,
 	0
 };
 char *g_flags_name[MAXGF] = {
@@ -76,7 +81,8 @@
 	"trace-all",
 	"safe-branches",
 	"comment-ic",
-	"comment-misc"
+	"comment-misc",
+	"patch-not"
 };
 union ppi g_flags_val[MAXGF];
 
@@ -337,20 +343,16 @@
 
 /* Extract the sign extended byte n of a value. */
 
-static char xbyte(zmax val, int byte)
+static unsigned char xbyte(zmax val, int byte)
 {
-	val <<= (sizeof(val)*8) - (byte*8) - 8;
-	val >>= (sizeof(val)*8) - 8;
-	return (unsigned char) val;
+	return val >> (byte*8);
 }
 
 /* Extract the sign extended word n of a value. */
 
-static zshort xword(zmax val, int word)
+static short xword(zmax val, int word)
 {
-	val <<= (sizeof(val)*8) - (word*16) - 16;
-	val >>= (sizeof(val)*8) - 16;
-	return (zshort) val;
+	return val >> (word*16);
 }
 
 /* Debug function: prints the text name of a type. */
@@ -428,17 +430,12 @@
 				break;
 
 			case FLOAT:
-				fprintf(fp, "[float #%04X]", obj->val.vfloat);
+				fprintf(fp, "[float #%f]", obj->val.vfloat);
 				break;
 
 			case DOUBLE:
-				fprintf(fp, "[double #%08X]", obj->val.vdouble);
+				fprintf(fp, "[double #%f]", obj->val.vdouble);
 				break;
-#if 0
-			case POINTER:
-				fprintf(fp, "[pointer #%04X]", obj->val.vpointer);
-				break;
-#endif
 		}
 	}
 	else if (f == REG)
@@ -455,13 +452,15 @@
 		if ((obj->v->storage_class == AUTO) ||
 		    (obj->v->storage_class == REGISTER))
 		{
-			zmax offset = obj->v->offset;
-			//if (offset < 0)
-			//	offset = -(offset+maxalign);
-			fprintf(fp, " at fp%+d", offset);
+			int offset = obj->v->offset;
+			if (offset == NOT_ON_STACK) {
+				fprintf(fp, " (not on stack)", offset);
+			} else {
+				fprintf(fp, " at fp%+d", offset);
+			}
 		}
 
-		fprintf(fp, "+%ld", obj->val.vlong);
+		fprintf(fp, "+%d", (int)obj->val.vlong);
 
 		if (f & REG)
 			fprintf(fp, " in %s", regnames[obj->reg]);
@@ -503,19 +502,7 @@
 		case MINUS:		p = "MINUS";		break;
 		case ADDRESS:		p = "ADDRESS";		break;
 		case CALL:		p = "CALL";		break;
-#if 0
-		case CONVCHAR:		p = "CONVCHAR";		break;
-		case CONVSHORT:		p = "CONVSHORT";	break;
-		case CONVINT:		p = "CONVINT";		break;
-		case CONVLONG:		p = "CONVLONG";		break;
-		case CONVFLOAT:		p = "CONVFLOAT";	break;
-		case CONVDOUBLE:	p = "CONVDOUBLE";	break;
-		case CONVPOINTER:	p = "CONVPOINTER";	break;
-		case CONVUCHAR:		p = "CONVUCHAR";	break;
-		case CONVUSHORT:	p = "CONVUSHORT";	break;
-		case CONVUINT:		p = "CONVUINT";		break;
-		case CONVULONG:		p = "CONVULONG";	break;
-#endif
+		case CONVERT:		p = "CONVERT";		break;
 		case ALLOCREG:		p = "ALLOCREG";		break;
 		case FREEREG:		p = "FREEREG";		break;
 		case COMPARE:		p = "COMPARE";		break;
@@ -743,8 +730,8 @@
 			break;
 			
 		case STATIC:
-			fprintf(fp, "Array STATIC_%s_%ld ->\n",
-				modulename, var->offset);
+			fprintf(fp, "Array STATIC_%s_%d ->\n",
+				modulename, (int)var->offset);
 			currentvar.type = STATIC;
 			currentvar.val.number = var->offset;
 			currentvar.offset = 0;
@@ -757,7 +744,8 @@
 
 void gen_ds(FILE *fp, zmax size, struct Typ *typ)
 {
-	fprintf(fp, " %ld\n", size);
+	if (currentvar.offset != 0) ierror(0);
+	fprintf(fp, " %d\n", (int)size);
 	currentvar.offset += size;
 }
 
@@ -834,6 +822,8 @@
 zmax voff(struct obj* obj)
 {
 	zmax offset = obj->v->offset;
+	if (offset == NOT_ON_STACK)
+		return NOT_ON_STACK;  /* this result should never be used */
 	if (offset < 0)
 		offset = stackparamadjust + stackoffset - offset - maxalign;
 	else
@@ -892,8 +882,8 @@
 	switch (obj->v->storage_class)
 	{
 		case STATIC:
-			fprintf(fp, "STATIC_%s_%ld",
-				modulename, obj->v->offset);
+			fprintf(fp, "STATIC_%s_%d",
+				modulename, (int)obj->v->offset);
 			break;
 
 		case EXTERN:
@@ -956,10 +946,10 @@
 		case AUTO:
 		case REGISTER: /* Local variable */
 		{
-			zmax offset = voff(obj);
+			int offset = voff(obj);
 
 			if ((typf & NQ) == CHAR)
-				fprintf(fp, "\t@storeb xp 0%+ld %s;\n",
+				fprintf(fp, "\t@storeb xp 0%+d %s;\n",
 					offset, regnames[reg]);
 			else
 			{
@@ -973,7 +963,7 @@
 					fprintf(fp, "\t@storew sp 0 %s;\n", regnames[reg]);
 				}
 				else
-					fprintf(fp, "\t@storew xp 0%+ld %s;\n",
+					fprintf(fp, "\t@storew xp 0%+d %s;\n",
 						offset >> 1, regnames[reg]);
 			}
 			return;
@@ -988,8 +978,8 @@
 			{
 				fprintf(fp, "\t@storeb ");
 				emit_identifier(fp, obj);
-				fprintf(fp, " 0%+ld %s;\n",
-					obj->val.vlong, regnames[reg]);
+				fprintf(fp, " 0%+d %s;\n",
+					(int)obj->val.vlong, regnames[reg]);
 			}
 			else
 			{
@@ -997,8 +987,8 @@
 				{
 					fprintf(fp, "\t@add ");
 					emit_identifier(fp, obj);
-					fprintf(fp, " 0%+ld -> sp;\n",
-						obj->val.vlong);
+					fprintf(fp, " 0%+d -> sp;\n",
+						(int)obj->val.vlong);
 					fprintf(fp, "\t@storew sp 0 %s;\n",
 						regnames[reg]);
 				}
@@ -1006,8 +996,8 @@
 				{
 					fprintf(fp, "\t@storew ");
 					emit_identifier(fp, obj);
-					fprintf(fp, " 0%+ld %s;\n",
-						obj->val.vlong >> 1, regnames[reg]);
+					fprintf(fp, " 0%+d %s;\n",
+						(int)(obj->val.vlong >> 1), regnames[reg]);
 				}
 			}
 			return;
@@ -1071,12 +1061,6 @@
 	int flags = obj->flags &
 		(KONST|REG|VAR|DREFOBJ|VARADR);
 
-	/* The only thing you can do with a function is to take the address of
-	 * it. */
-
-	if ((typf & NQ) == FUNKT)
-		flags &= ~DREFOBJ & ~VARADR;
-
 	/* Is this a memory dereference? */
 
 	if (flags & DREFOBJ)
@@ -1096,7 +1080,7 @@
 			case UNSIGNED|CHAR:	c.val.constant = obj->val.vuchar;	break;
 			case SHORT:		c.val.constant = obj->val.vshort;	break;
 			case UNSIGNED|SHORT:	c.val.constant = obj->val.vushort;	break;
-		case POINTER:	      ierror(0);
+			case POINTER:	      	c.val.constant = obj->val.vulong;	break;
 			case INT:		c.val.constant = obj->val.vint;		break;
 			case UNSIGNED|INT:	c.val.constant = obj->val.vuint;	break;
 			default:
@@ -1127,8 +1111,8 @@
 			case REGISTER: /* Local variable */
 				if (flags & VARADR)
 				{
-					fprintf(fp, "\t@add xp 0%+ld -> %s;\n",
-						voff(obj), regnames[reg]);
+					fprintf(fp, "\t@add xp 0%+d -> %s;\n",
+						(int)voff(obj), regnames[reg]);
 				}
 				else if (flags & REG)
 				{
@@ -1138,20 +1122,20 @@
 				}
 				else
 				{
-					zmax offset = voff(obj);
+					int offset = voff(obj);
 
 					if ((typf & NQ) == CHAR)
-						fprintf(fp, "\t@loadb xp 0%+ld -> %s;\n",
+						fprintf(fp, "\t@loadb xp 0%+d -> %s;\n",
 							offset, regnames[reg]);
 					else
 					{
 						if (offset & 1)
 						{
-							fprintf(fp, "\t@add xp 0%+ld -> sp;\n", offset);
+							fprintf(fp, "\t@add xp 0%+d -> sp;\n", offset);
 							fprintf(fp, "\t@loadw sp 0 -> %s;\n", regnames[reg]);
 						}
 						else
-							fprintf(fp, "\t@loadw xp 0%+ld -> %s;\n",
+							fprintf(fp, "\t@loadw xp 0%+d -> %s;\n",
 								offset >> 1, regnames[reg]);
 					}
 				}
@@ -1170,12 +1154,12 @@
 
 					fprintf(fp, "\t@add ");
 					emit_identifier(fp, obj);
-					fprintf(fp, " 0%+ld -> %s;\n",
-						obj->val.vlong, regnames[reg]);
+					fprintf(fp, " 0%+d -> %s;\n",
+						(int)obj->val.vlong, regnames[reg]);
 				}
 				else if (strcmp(obj->v->identifier, "__va_start") == 0)
 				{
-					fprintf(fp, "\t@add xp 0%+ld -> %s;\n",
+					fprintf(fp, "\t@add xp 0%+d -> %s;\n",
 						find_varargs(), regnames[reg]);
 				}
 				else
@@ -1186,8 +1170,8 @@
 					{
 						fprintf(fp, "\t@loadb ");
 						emit_identifier(fp, obj);
-						fprintf(fp, " 0%+ld -> %s;\n",
-							obj->val.vlong, regnames[reg]);
+						fprintf(fp, " 0%+d -> %s;\n",
+							(int)obj->val.vlong, regnames[reg]);
 					}
 					else
 					{
@@ -1195,8 +1179,8 @@
 						{
 							fprintf(fp, "\t@add ");
 							emit_identifier(fp, obj);
-							fprintf(fp, " 0%+ld -> sp;\n",
-								obj->val.vlong);
+							fprintf(fp, " 0%+d -> sp;\n",
+								(int)obj->val.vlong);
 							fprintf(fp, "\t@loadw sp 0 -> %s;\n",
 								regnames[reg]);
 						}
@@ -1204,8 +1188,8 @@
 						{
 							fprintf(fp, "\t@loadw ");
 							emit_identifier(fp, obj);
-							fprintf(fp, " 0%+ld -> %s;\n",
-								obj->val.vlong >> 1, regnames[reg]);
+							fprintf(fp, " 0%+d -> %s;\n",
+								(int)(obj->val.vlong >> 1), regnames[reg]);
 						}
 					}
 				}
@@ -1224,7 +1208,7 @@
 	obj->flags &= ~DREFOBJ;
 	read_reg(fp, obj, POINTER, 0);
 		
-	if (flags & DREFOBJ)
+	if ((flags & DREFOBJ) && typf != FUNKT)
 	{
 		switch (typf & NQ)
 		{
@@ -1266,18 +1250,13 @@
 			case UNSIGNED|SHORT:	op->val.constant = obj->val.vushort;	break;
 			case INT:		op->val.constant = obj->val.vint;	break;
 			case UNSIGNED|INT:	op->val.constant = obj->val.vuint;	break;
-		case POINTER:		ierror(0);
+			case POINTER:		op->val.constant = obj->val.vulong;	break;
 			default:
 				fprintf(fp, "XXX !!! bad konst type %X\n", typf);
 		}
 		return;
 	}
 
-	/* The only thing you can do with a function is to take the address of it. */
-
-	if ((typf & NQ) == FUNKT)
-		flags &= ~DREFOBJ & ~VARADR;
-
 	/* This is used by the long code. The longop functions can only operate
 	 * on pointers to longs; so if we need to pass in a constant, we have
 	 * to stash it on the stack and return a pointer. */
@@ -1309,7 +1288,7 @@
 
 	if ((flags == (VAR|VARADR)) &&
 	    (obj->v->storage_class == EXTERN) &&
-	    (obj->v->offset == 0))
+	    (obj->val.vlong == 0))
 	{
 		debugemit(fp, "! zop varaddr extern %s\n", obj->v->identifier);
 		op->type = ZOP_EXTERN;
@@ -1319,7 +1298,7 @@
 
 	if ((flags == (VAR|VARADR)) &&
 	    (obj->v->storage_class == STATIC) &&
-	    (obj->v->offset == 0))
+	    (obj->val.vlong == 0))
 	{
 		debugemit(fp, "! zop varaddr static %ld\n", obj->v->offset);
 		op->type = ZOP_STATIC;
@@ -1404,7 +1383,7 @@
 			return;
 
 		case ZOP_CONSTANT:
-			fprintf(fp, "0%+ld", (zshort)op->val.constant);
+			fprintf(fp, "0%+d", (short)op->val.constant);
 			return;
 
 		case ZOP_EXTERN:
@@ -1412,13 +1391,13 @@
 			return;
 
 		case ZOP_STATIC:
-			fprintf(fp, "STATIC_%s_%ld",
-				modulename, op->val.constant);
+			fprintf(fp, "STATIC_%s_%d",
+				modulename, (int)op->val.constant);
 			return;
 
 		case ZOP_CONSTANTADDR:
-			fprintf(fp, "CONSTANT_%s_%ld",
-				modulename, op->val.constant);
+			fprintf(fp, "CONSTANT_%s_%d",
+				modulename, (int)op->val.constant);
 			return;
 
 		default:
@@ -1585,7 +1564,7 @@
 		push_addrof(fp, z, POINTER, &zz);
 		fprintf(fp, "\t@call_vn __long_loadconst ");
 		emit_zop(fp, &zz);
-		fprintf(fp, " 0%+ld 0%+ld;\n", (short)hi, (short)lo);
+		fprintf(fp, " 0%+d 0%+d;\n", (short)hi, (short)lo);
 		return;
 	}
 
@@ -1598,6 +1577,98 @@
 	fprintf(fp, " 4;\n");
 }
 
+static int ssf_max = 0;
+static short *ssf_frameusage = NULL;
+
+void ssf_record_frameusage(int where, int len)
+{
+	if (!(len >= 1)) ierror(0);
+	if (!(0 <= where && where+len <= ssf_max)) ierror(0);
+	while (len--) {
+		ssf_frameusage[where+len] = 1;
+	}
+}
+
+int ssf_record_object(struct obj *obj)
+{
+	if (obj->flags & VAR) {
+		int sc = obj->v->storage_class;
+		if (sc != AUTO && sc != REGISTER)
+			return 0;  /* don't care about non-stack vars */
+		/* Mark this variable for updating later. */
+		obj->v->nesting = 1;
+		if (obj->flags & REG) {
+			if (obj->flags & VARADR) ierror(0);
+			return 0;  /* it's allocated to a register */
+		}
+		/* don't optimize function containing pointer arithmetic
+		 * on stack objects */
+		if (obj->flags & VARADR)
+			return 1;
+		/* don't optimize function containing VLA */
+		if (obj->v->vtyp->dsize != NULL)
+			return 1;
+		ssf_record_frameusage(obj->v->offset, szof(obj->v->vtyp));
+	}
+	return 0;
+}
+
+void ssf_update_object(struct obj *obj)
+{
+	if (obj->flags & VAR) {
+		int sc = obj->v->storage_class;
+		if (sc != AUTO && sc != REGISTER)
+			return;  /* don't care about non-stack vars */
+		if (obj->v->nesting) {
+			if (ssf_frameusage[obj->v->offset] == -1) {
+				obj->v->offset = NOT_ON_STACK;
+			} else {
+				obj->v->offset = ssf_frameusage[obj->v->offset];
+			}
+			obj->v->nesting = 0;
+		}
+	}
+}
+
+/* The middle-end likes to make tons of temporaries on the stack and then
+ * mostly optimize them away, leaving a "stackframe" of several thousand
+ * sparsely occupied bytes. This little hack counts the stack space that's
+ * actually being used, and squashes the remaining variables down into
+ * that smaller space. */
+int squash_stack_frame(struct IC *orig_ic, zmax stackframe)
+{
+	struct IC *ic;
+	int bytes_used;
+	int i;
+
+	ssf_max = stackframe;
+	ssf_frameusage = realloc(ssf_frameusage, ssf_max * sizeof *ssf_frameusage);
+	memset(ssf_frameusage, -1, ssf_max * sizeof *ssf_frameusage);
+
+	for (ic = orig_ic; ic != NULL; ic = ic->next) {
+		/* Record the bytes actually referenced by this IC's operands.
+		 * If optimization is inhibited, return the old stackframe. */
+		if (ssf_record_object(&ic->q1)) return stackframe;
+		if (ssf_record_object(&ic->q2)) return stackframe;
+		if (ssf_record_object(&ic->z)) return stackframe;
+	}
+
+	bytes_used = 0;
+	for (i=0; i < ssf_max; ++i) {
+		if (ssf_frameusage[i] != -1) {
+			ssf_frameusage[i] = bytes_used++;
+		}
+	}
+	
+	for (ic = orig_ic; ic != NULL; ic = ic->next) {
+		ssf_update_object(&ic->q1);
+		ssf_update_object(&ic->q2);
+		ssf_update_object(&ic->z);
+	}
+
+	return bytes_used;
+}
+
 /* The code generator itself.
  * This big, complicated, hairy and scary function does the work to actually
  * produce the code.  fp is the output stream, ic the beginning of the ic
@@ -1615,6 +1686,8 @@
 
     int c,t,lastcomp=0,reg;
 	    
+	stackframe = squash_stack_frame(ic, stackframe);
+    
     	function = func;
 
 	/* r0..r5 are always used for parameter passing. */
@@ -1638,7 +1711,7 @@
 	reflower(fp);
 
 	if (func->storage_class == STATIC)
-		fprintf(fp, "[ STATIC_%s_%ld xp\n", modulename, func->offset);
+		fprintf(fp, "[ STATIC_%s_%d xp\n", modulename, (int)func->offset);
 	else
 		fprintf(fp, "[ _%s xp\n", func->identifier);
 
@@ -1658,7 +1731,7 @@
 	if (g_flags[1] & USEDFLAG)
 	{
 		if (func->storage_class == STATIC)
-			fprintf(fp, "print \"STATIC_%s_%ld^\";\n", modulename, func->offset);
+			fprintf(fp, "print \"STATIC_%s_%d^\";\n", modulename, (int)func->offset);
 		else
 			fprintf(fp, "print \"_%s^\";\n", func->identifier);
 	}
@@ -1666,7 +1739,7 @@
 	/* Adjust stack for locals. */
 
 	if (stackframe)
-		fprintf(fp, "\t@sub xp 0%+ld -> xp;\n", stackframe);
+		fprintf(fp, "\t@sub xp 0%+d -> xp;\n", (int)stackframe);
 	//if (stackoffset)
 	//	fprintf(fp, "\txp = xp - %ld\n", stackframe);
 
@@ -1862,17 +1935,29 @@
 				continue;
 
 			case KOMPLEMENT: /* Unary komplement */
-				/* INFORM BUG! */
-				/* The @not opcode doesn't work. We have to use a
-				 * wrapper function instead. */
-				
 				push_value(fp, &ic->q1, typf, &q1);
 				pop_value(fp, &ic->z, typf, &z);
-				fprintf(fp, "\t@call_2s __not ");
-				emit_zop(fp, &q1);
-				fprintf(fp, " -> ");
-				emit_zop(fp, &z);
-				fprintf(fp, ";\n");
+				if (g_flags[6] & USEDFLAG) {
+					/* Prior to Inform 6.30, the assembler
+					 * had a major bug in the @not opcode;
+					 * it would generate bogus code and
+					 * crash some Z-machine interpreters. */
+					fprintf(fp, "\t@call_2s __not ");
+					emit_zop(fp, &q1);
+					fprintf(fp, " -> ");
+					emit_zop(fp, &z);
+					fprintf(fp, ";\n");
+				} else {
+					/* The bug was fixed in Inform 6.30.
+					 * The current distribution of Inform 6
+					 * is 6.31; the version distributed
+					 * with Inform 7 is 6.32. */
+					fprintf(fp, "\t@not ");
+					emit_zop(fp, &q1);
+					fprintf(fp, " -> ");
+					emit_zop(fp, &z);
+					fprintf(fp, ";\n");
+				}
 				fin_zop(fp, &ic->z, typf, &z);
 				continue;
 
@@ -1912,7 +1997,7 @@
 						emit_zop(fp, &q1);
 						fprintf(fp, " ");
 						emit_zop(fp, &z);
-						fprintf(fp, " 0%+ld;\n", ic->q2.val.vlong);
+						fprintf(fp, " 0%+d;\n", (int)ic->q2.val.vlong);
 						break;
 
 					default:
@@ -1924,15 +2009,15 @@
 					 AUTO or STATIC */
 				i = voff(&ic->q1);
 				pop_value(fp, &ic->z, typf, &z);
-				fprintf(fp, "\t@add xp 0%+ld -> ", i);
+				fprintf(fp, "\t@add xp 0%+d -> ", i);
 				emit_zop(fp, &z);
 				fprintf(fp, ";\n");
 				fin_zop(fp, &ic->z, typf, &z);
 				continue;
 
 			case PUSH: /* Push a value onto the stack */
-				fprintf(fp, "\t@sub xp 0%+ld -> xp;\n",
-					ic->q2.val.vlong);
+				fprintf(fp, "\t@sub xp 0%+d -> xp;\n",
+					(int)ic->q2.val.vlong);
 				//stackoffset += ic->q2.val.vlong;
 				stackparamadjust += ic->q2.val.vlong;
 
@@ -1956,7 +2041,7 @@
 						push_addrof(fp, &ic->q1, typf, &q1);
 						fprintf(fp, "\t@copy_table ");
 						emit_zop(fp, &q1);
-						fprintf(fp, " xp 0%+ld;\n", ic->q2.val.vlong);
+						fprintf(fp, " xp 0%+d;\n", (int)ic->q2.val.vlong);
 						break;
 				}
 				continue;
@@ -2545,12 +2630,10 @@
 				/* If any parameters have been pushed, adjust
 				 * the stack to pop them. */
 
-				if (stackparamadjust)
-				{
-					fprintf(fp, "\t@add xp 0%+ld -> xp;\n",
-						stackparamadjust);
-					//stackoffset -= stackparamadjust;
-					stackparamadjust = 0;
+				int this_call_adjust = pushedargsize(ic);
+				if (this_call_adjust) {
+					fprintf(fp, "\t@add xp 0%+d -> xp;\n", this_call_adjust);
+					stackparamadjust -= this_call_adjust;
 				}
 				continue;
 			}
@@ -2622,9 +2705,9 @@
 
 		while (constant)
 		{
-			fprintf(fp, "Array CONSTANT_%s_%ld -->\n",
+			fprintf(fp, "Array CONSTANT_%s_%d -->\n",
 				modulename, constant->id);
-			fprintf(fp, " 0%+ld 0%+ld;\n",
+			fprintf(fp, " 0%+d 0%+d;\n",
 				xword(constant->value, 1),
 				xword(constant->value, 0));
 			constant = constant->next;
@@ -2639,12 +2722,12 @@
 		fprintf(fp, "[ __init_vars_%s;\n", modulename);
 		while (fixup)
 		{
-			fprintf(fp, "\t@add 0%+ld ", fixup->offset);
+			fprintf(fp, "\t@add 0%+d ", (int)fixup->offset);
 
 			switch (fixup->value.type)
 			{
 				case STATIC:
-					fprintf(fp, "STATIC_%s_%ld -> sp;\n",
+					fprintf(fp, "STATIC_%s_%d -> sp;\n",
 						modulename, fixup->value.val.number);
 					break;
 
@@ -2660,15 +2743,15 @@
 			switch (fixup->identifier.type)
 			{
 				case STATIC:
-					fprintf(fp, "\t@storew STATIC_%s_%ld 0%+ld sp;\n",
+					fprintf(fp, "\t@storew STATIC_%s_%d 0%+d sp;\n",
 						modulename, fixup->identifier.val.number,
-						fixup->identifier.offset);
+						fixup->identifier.offset >> 1);
 					break;
 
 				case EXTERN:
-					fprintf(fp, "\t@storew _%s 0%+ld sp;\n",
+					fprintf(fp, "\t@storew _%s 0%+d sp;\n",
 						fixup->identifier.val.identifier,
-						fixup->identifier.offset);
+						fixup->identifier.offset >> 1);
 					break;
 
 				default:
diff -Nur vbcc/machines/z/machine.h vbcc-patched/machines/z/machine.h
--- vbcc/machines/z/machine.h	2012-06-05 12:54:33.000000000 -0700
+++ vbcc-patched/machines/z/machine.h	2012-06-05 11:17:56.000000000 -0700
@@ -18,7 +18,7 @@
 
 /* Number of command-line options we accept. */
 
-#define MAXGF 6
+#define MAXGF 7
 
 /* If this is set to zero vbcc will not generate ICs where the target operand
  * is the same as the 2nd source operand. This can sometimes simplify the
diff -Nur vbcc/Makefile vbcc-patched/Makefile
--- vbcc/Makefile	2012-06-05 12:54:33.000000000 -0700
+++ vbcc-patched/Makefile	2012-06-05 11:17:56.000000000 -0700
@@ -1,6 +1,6 @@
 
 # used to create vbcc, vc and ucpp
-CC = gcc -std=c9x -g -DHAVE_AOS4 #-DHAVE_ECPP -DHAVE_MISRA
+CC = gcc -std=c9x -g -Wno-format-security #-DHAVE_AOS4 -DHAVE_ECPP -DHAVE_MISRA
 LDFLAGS = -lm
 
 # native version; used to create dtgen
