diff -Nur vbcc/config/z vbcc-patched/config/z
--- vbcc/config/z	1969-12-31 16:00:00.000000000 -0800
+++ vbcc-patched/config/z	2012-05-02 23:25:11.883830273 -0700
@@ -0,0 +1,5 @@
+-cc=../bin/vbccz -quiet %s -o=%s %s -O=%ld
+-ccv=../bin/vbccz %s -o=%s %s -O=%ld
+-as=cp %s %s
+-ld=echo "Don't know how to link Z-machine code" 1>&2; exit 0
+-rm=rm %s
diff -Nur vbcc/datatypes/dtgen.c vbcc-patched/datatypes/dtgen.c
--- vbcc/datatypes/dtgen.c	2012-05-02 23:35:05.371816638 -0700
+++ vbcc-patched/datatypes/dtgen.c	2012-05-02 23:25:11.883830273 -0700
@@ -133,8 +133,8 @@
   do{
     printf("Type y or n [%s]: ",def);
     fflush(stdout);
-    fgets(in,sizeof(in),stdin);
-    if(*in=='\n') strcpy(in,def);
+    if (fgets(in,sizeof(in),stdin) == NULL || *in == '\n')
+      strcpy(in,def);
   }while(*in!='y'&&*in!='n');
   return *in=='y';
 }
diff -Nur vbcc/frontend/vc.c vbcc-patched/frontend/vc.c
--- vbcc/frontend/vc.c	2012-05-02 23:35:05.379816637 -0700
+++ vbcc-patched/frontend/vc.c	2012-05-02 23:25:11.883830273 -0700
@@ -2,6 +2,7 @@
 /*  (c) in 1995-2010 by Volker Barthelmann  */
 /*  #define AMIGA for Amiga-Version         */
 
+#include <assert.h>
 #include <stdlib.h>
 #include <string.h>
 #include <stdio.h>
@@ -204,41 +205,50 @@
     }
 }
 
+static char *derelativize(int from_cfg, char *old_path)
+{
+    if (from_cfg && !strncmp(old_path, "../", 3)) {
+        char *vbcc_dir = getenv("VBCC");
+        int vbcc_dir_len;
+        char *new_path;
+        assert(vbcc_dir != NULL);  /* or we'd already have bailed */
+        vbcc_dir_len = strlen(vbcc_dir);
+        new_path = malloc(vbcc_dir_len + 1 + strlen(old_path+3) + 1);
+        sprintf(new_path, "%s%s%s",
+                vbcc_dir,
+                vbcc_dir[vbcc_dir_len-1] == '/' ? "" : "/",
+                old_path+3);
+        return new_path;
+    }
+    return old_path;
+}
+
 static int read_config(const char *cfg_name)
 {
     int i,count; long size;
-    char *p,*name;
-    FILE *file=0;
-    for(i=0;i<sizeof(search_dirs)/sizeof(search_dirs[0]);i++){
-      name=malloc(strlen(search_dirs[i])+strlen(cfg_name)+1);
-      if(!name) {printf(nomem);raus(EXIT_FAILURE);}
-      strcpy(name,search_dirs[i]);
-      strcat(name,cfg_name);
-      file=fopen(name,"r");
-      free(name);
-      if(file) break;
-    }
-    if(!file){
-      p=getenv("VBCC");
-      if(p){
-        name=malloc(strlen(p)+strlen(cfg_name)+20);
-        if(!name){printf(nomem);raus(EXIT_FAILURE);}
-        strcpy(name,p);
-#if defined(_WIN32)||defined(MSDOS)||defined(ATARI)
-        strcat(name,"\\config\\");
-        strcat(name,cfg_name);
-#elif defined(AMIGA)
-        AddPart(name,"config",strlen(p)+strlen(cfg_name)+20);
-        AddPart(name,(STRPTR)cfg_name,strlen(p)+strlen(cfg_name)+20);
-#else
-        strcat(name,"/config/");
-        strcat(name,cfg_name);
-#endif
-        file=fopen(name,"r");
-        free(name);
-      }
+    char *p;
+    char *vbcc_dir = getenv("VBCC");
+    int vbcc_dir_len;
+    char *config_fullpath;
+    FILE *file;
+    if (vbcc_dir == NULL) {
+        puts("Environment variable VBCC must point to the vbcc install directory!");
+        raus(EXIT_FAILURE);
+    }
+    vbcc_dir_len = strlen(vbcc_dir);
+    config_fullpath = malloc(vbcc_dir_len + 1 + 7 + strlen(cfg_name) + 1);
+    sprintf(config_fullpath, "%s%s%s%s",
+            vbcc_dir,
+            vbcc_dir[vbcc_dir_len-1] == '/' ? "" : "/",
+            "config/",
+            cfg_name);
+    file = fopen(config_fullpath, "r");
+    if (file == NULL) {
+        printf("Config file %s not found!\n"
+               "Is environment variable VBCC set correctly?\n",
+               config_fullpath);
+        raus(EXIT_FAILURE);
     }
-    if(!file) {puts("No config file!");raus(EXIT_FAILURE);}
     if(fseek(file,0,SEEK_END)) return 0;
     size=ftell(file);
     if(fseek(file,0,SEEK_SET)) return 0;
@@ -333,25 +343,26 @@
         if(!strncmp(parm,"-ul=",4)){ul=parm+4;*parm=0;}
     }
     for(i=1;i<argc+count;i++){
-        if(i<argc) parm=argv[i]; else parm=confp[i-argc];
+        int from_cfg = (i >= argc);
+        parm = (from_cfg ? confp[i-argc] : argv[i]);
 /*        printf("Parameter %d=%s\n",i,parm);*/
         if(!strncmp(parm,"-ldnodb=",8)){nodb=parm+8;*parm=0;}
         if(!strncmp(parm,"-ldstatic=",10)){staticflag=parm+10;*parm=0;}
         if(!strcmp(parm,"-g")) db=1;
         if(!strcmp(parm,"-static")){staticmode=1;*parm=0;}
         if(!strncmp(parm,"-ml=",4)){MAXCLEN=atoi(parm+4);*parm=0;}
-        if(!strncmp(parm,"-pp=",4)){ppname=parm+4;*parm=0;}
-        if(!strncmp(parm,"-cc=",4)){ccname=parm+4;*parm=0;}
-        if(!strncmp(parm,"-as=",4)){asname=parm+4;*parm=0;}
-        if(!strncmp(parm,"-ld=",4)){ldname=parm+4;*parm=0;}
-        if(!strncmp(parm,"-l2=",4)){l2name=parm+4;*parm=0;}
-        if(!strncmp(parm,"-rm=",4)){rmname=parm+4;*parm=0;}
-        if(!strncmp(parm,"-ppv=",5)){ppv=parm+5;*parm=0;}
-        if(!strncmp(parm,"-ccv=",5)){ccv=parm+5;*parm=0;}
-        if(!strncmp(parm,"-asv=",5)){asv=parm+5;*parm=0;}
-        if(!strncmp(parm,"-ldv=",5)){ldv=parm+5;*parm=0;}
-        if(!strncmp(parm,"-l2v=",5)){l2v=parm+5;*parm=0;}
-        if(!strncmp(parm,"-rmv=",5)){rmv=parm+5;*parm=0;}
+        if(!strncmp(parm,"-pp=",4)){ppname=derelativize(from_cfg, parm+4);*parm=0;}
+        if(!strncmp(parm,"-cc=",4)){ccname=derelativize(from_cfg, parm+4);*parm=0;}
+        if(!strncmp(parm,"-as=",4)){asname=derelativize(from_cfg, parm+4);*parm=0;}
+        if(!strncmp(parm,"-ld=",4)){ldname=derelativize(from_cfg, parm+4);*parm=0;}
+        if(!strncmp(parm,"-l2=",4)){l2name=derelativize(from_cfg, parm+4);*parm=0;}
+        if(!strncmp(parm,"-rm=",4)){rmname=derelativize(from_cfg, parm+4);*parm=0;}
+        if(!strncmp(parm,"-ppv=",5)){ppv=derelativize(from_cfg, parm+5);*parm=0;}
+        if(!strncmp(parm,"-ccv=",5)){ccv=derelativize(from_cfg, parm+5);*parm=0;}
+        if(!strncmp(parm,"-asv=",5)){asv=derelativize(from_cfg, parm+5);*parm=0;}
+        if(!strncmp(parm,"-ldv=",5)){ldv=derelativize(from_cfg, parm+5);*parm=0;}
+        if(!strncmp(parm,"-l2v=",5)){l2v=derelativize(from_cfg, parm+5);*parm=0;}
+        if(!strncmp(parm,"-rmv=",5)){rmv=derelativize(from_cfg, parm+5);*parm=0;}
         if(!strncmp(parm,"-cf=",4)){cf=parm+4;*parm=0;}
         if(!strncmp(parm,"-isc=",5)){scname=parm+5;*parm=0;}
         if(!strncmp(parm,"-iscv=",6)){scv=parm+6;*parm=0;}
diff -Nur vbcc/ic.c vbcc-patched/ic.c
--- vbcc/ic.c	2012-05-02 23:35:05.379816637 -0700
+++ vbcc-patched/ic.c	2012-05-02 23:34:47.511817048 -0700
@@ -915,6 +915,74 @@
         struct IC *merk_fp,*lp;
 	unsigned int merk_opushed=opushed;
 #endif
+	/* [ajo] The following code optimizes puts("hello") into a single
+	 * Z-machine opcode: print "hello". This cuts down a little bit on
+	 * code size, but greatly on static data size, because (as far as I
+	 * know) the Z-machine stores text strings differently from regular
+	 * static data. */
+        if (p->left->flags==ADDRESS &&
+            p->left->left->flags==IDENTIFIER &&
+            p->left->left->o.v->storage_class==EXTERN &&
+            !strcmp(p->left->left->o.v->identifier, "puts")) {
+            /* Generating IC for puts() of something */
+            struct argument_list *al = p->alist;
+            if (al != NULL && al->arg != NULL && al->next == NULL &&
+                al->arg->left != NULL && al->arg->left->flags == STRING) {
+                /* Generating IC for puts() of a string literal */
+                int optimize = 1;
+                char *puts_buffer = mymalloc(100);
+                int len = 0, cap = 100;
+                struct const_list *cl = al->arg->left->cl;
+                strcpy(puts_buffer, "\tprint \"");
+                len = 8;
+                while (cl != NULL) {
+                    int ch = cl->other->val.vchar;
+                    cl = cl->next;
+                    if (ch == '\0') break;
+                    if (len == cap-16) {
+                        puts_buffer = myrealloc(puts_buffer, cap *= 2);
+                    }
+                    switch (ch) {
+                        case '\n': puts_buffer[len++] = '^'; break;
+                        case '\t': strcpy(puts_buffer+len, "@{9}"); len += 4; break;
+                        case '"': puts_buffer[len++] = '~'; break;
+                        case '@': strcpy(puts_buffer+len, "@{40}"); len += 5; break;
+                        case '\\': strcpy(puts_buffer+len, "@{5c}"); len += 5; break;
+                        case '^': optimize = 0; break;
+                        case '~': strcpy(puts_buffer+len, "@{7e}"); len += 5; break;
+                        default:
+                            puts_buffer[len++] = ch;
+                            if (ch < 32 || ch > 126)
+                                optimize = 0;
+                            break;
+                    }
+                }
+                if (optimize) {
+                    strcpy(puts_buffer+len, "^\";\n");
+                    /* Now we need to turn this into a CALL of a made-up function
+                     * with appropriate inline assembly. */
+                    char pfname[50];
+                    static int counter = 0;
+                    struct Typ voidt = {VOID};
+                    struct Typ *voidfunctyp = new_typ();
+                    sprintf(pfname, "XXinternal_pf_%07x_puts", ++counter);
+                    voidfunctyp->next = clone_typ(&voidt);  /* returning void */
+                    voidfunctyp->exact = mymalloc(sizeof *voidfunctyp->exact);
+                    voidfunctyp->exact->count = 0;  /* taking unspecified arguments */
+                    voidfunctyp->flags = FUNKT;
+                    struct Var *pseudofunc = add_var(pfname, voidfunctyp, EXTERN, NULL);
+                    pseudofunc->fi = new_fi();
+                    pseudofunc->fi->inline_asm = puts_buffer;
+                    p->left->left->o.v = pseudofunc;
+                    p->alist = NULL;
+                    gen_IC(p, ltrue, lfalse);
+                    return;
+                } else {
+                    free(puts_buffer);
+                }
+            }
+        }
+
         if(p->left->flags==ADDRESS&&p->left->left->flags==IDENTIFIER){
             struct Var *v;
             gen_IC(p->left,0,0); r=1;
diff -Nur vbcc/machines/z/machine.c vbcc-patched/machines/z/machine.c
--- vbcc/machines/z/machine.c	2012-05-02 23:35:05.387816638 -0700
+++ vbcc-patched/machines/z/machine.c	2012-05-02 23:25:11.887830273 -0700
@@ -60,6 +60,8 @@
 static char FILE_[]=__FILE__;
 char cg_copyright[]="vbcc code-generator for Z-machine V0.0a (c) in 2001 by David Given";
 
+extern char *strdup(const char *);
+
 /* Command-line flags. */
 
 int g_flags[MAXGF] = {
@@ -1096,7 +1098,7 @@
 			case UNSIGNED|CHAR:	c.val.constant = obj->val.vuchar;	break;
 			case SHORT:		c.val.constant = obj->val.vshort;	break;
 			case UNSIGNED|SHORT:	c.val.constant = obj->val.vushort;	break;
-		case POINTER:	      ierror(0);
+			case POINTER:	      	c.val.constant = obj->val.vulong;	break;
 			case INT:		c.val.constant = obj->val.vint;		break;
 			case UNSIGNED|INT:	c.val.constant = obj->val.vuint;	break;
 			default:
@@ -1266,7 +1268,7 @@
 			case UNSIGNED|SHORT:	op->val.constant = obj->val.vushort;	break;
 			case INT:		op->val.constant = obj->val.vint;	break;
 			case UNSIGNED|INT:	op->val.constant = obj->val.vuint;	break;
-		case POINTER:		ierror(0);
+			case POINTER:		op->val.constant = obj->val.vulong;	break;
 			default:
 				fprintf(fp, "XXX !!! bad konst type %X\n", typf);
 		}
diff -Nur vbcc/Makefile vbcc-patched/Makefile
--- vbcc/Makefile	2012-05-02 23:35:05.367816638 -0700
+++ vbcc-patched/Makefile	2012-05-02 23:25:11.887830273 -0700
@@ -1,6 +1,6 @@
 
 # used to create vbcc, vc and ucpp
-CC = gcc -std=c9x -g -DHAVE_AOS4 #-DHAVE_ECPP -DHAVE_MISRA
+CC = gcc -std=c9x -g -Wno-format #-DHAVE_AOS4 -DHAVE_ECPP -DHAVE_MISRA
 LDFLAGS = -lm
 
 # native version; used to create dtgen
